# CH 2 Building blocks

This chapter covers

- Using the interactive shell
- Working with variables
- Organizing your code
- Understanding the type system
- Working with Operators
- Understanding the runtime



##  Working with variables

Elixir is a dynamic programming language -> It doesn't explicitly declare a variable or its type. Instead, the variable is determined by whatever data it contains at the moment. In Elixir terms, assignment is called *binding*. 

```elixir
monthly_salary = 10000
```

In Elixir, a variable name always starts with a lowercase alphabetic -> In Erlang Variable start with uppercase

```Erlang
#Erlang
A = 100.

#Elixir
a = 100
```



Also variable name can be end with the question mark or exclamation mark characters.  

Variable names can be rebound to a different value.

```elixir
#Erlang
A = 100.
A = 110.
#Error

#Elixir
a = 100
a = 110
#Possible

```

Elixir is a ***garbage-collection language.***  



## Organizing your code

### 2.3.1 Modules

A modules is a collection of functions, somewhat like a namespace. Every Elixir function must be defined inside a module.

A module name must follow certain rules. It starts with an uppercase letter and is usually written in CamelCase style.



### 2.3.2 Functions ###

 As with variable, function names can end with the ? and ! characters. The ? character is often used to indicate a function that returns either true or false. Placing the character ! at the end of the name indicates a function that may raise a runtime error.-> Both of these are conventions, rather than rules.

 Function can be defined using the def macro

```elixir
defmodul Geometry do
    def rectangle_area(a, b) do
    ...
	end
	
	def function_has_no_argument do
	...
	end
end	
```

 There is no explicit return in Elixir -> The return value of a function is the return value of its last expression.

```elixir
Geometry.rectangle(3,2)
Geometry.rectangle 3, 2

#Same expression
```

Elixir comes with a built-in operator, |>, called *pipeline operator*

```elixir
-5 |> abs() |> (Integer.to-string(abs(-5)))
```

Pipeline operator places the result of the previous call as the first argument of the next call. So the following code,

```elixir
prev(arg1, arg2) |> next(arg3, arg4)
#It means
next(prev(arg1, arg2), arg3, arg4)
```

***Multi-line pipelines don;t work in the shell***



### 2.3.3 Function arity ###

Arity is a fancy name of the number of arguments a function receives.

```elixir
defmodule Rectangle do
	def area(a), do: area(a,a)  %%Rectangle.area/1 -> 1 arity
	def area(a, b) do: a * b	%%Rectangle.area/2 -> 2 arity
```



```elixir
# Same-name functions, different arities, default params
defmodule Calculator do
    def sum(a) do
    	sum(a, 0)
    end
    
    def sum(a, b) do  
	    a + b
    end
end
```

A lower-arity function is implemented in terms of a higher-arity one, This pattern is so frequent that Elixir allows you to specify defaults for arguments by using the \ \\operaor followed by the ***argument's*** default value

```elixir
defmodule Clculator do
	def sum(a, b \\ 0) do
		a + b
	end
end
```

```elixir
defmodule MyModule do
	def fun(a, b \\ 1, c, d, \\ 2) do
		a + b + c + d
	end
end
```

>  Similar with argument of fun in C/C++ or other language
>
> But in Elixir, \\\ set default of ***multiple argument***



### 2.3.4 Function visibility ###

- def  : public function -> can be called by anyone else
- defp : A private function can be used inly inside the module it is defined in.    

```elixir
# Module with a public and a private function
defmodule TestPrivate do
    def double(a) do 		# Public function
        sum(a,b) 		# Calls the private function
    end

    defp sum(a,b) do		# Private function
        a + b
        end
    end    
```



### 2.3.5 Imports and aliases

Calling functions from another module can sometimes be cumbersome because it needs to reference the module name. Importing a module allows to call its public functions without prefixing them.



```elixir
defmodule MyModule do
	import IO
	
	def my_function do
		puts "Calling imported function"
		#IO:puts "Calling imported function"
	end
end
```



Of course, multiple modules can be imported. In fact, the standard library's *kernel* module is automatically imported into every module.

Another construct, *alias*, makes it possible to reference a module under a different name.

```elixir
def MyModule do
    alias IO, as MyIO
    
    def my_function do
    	MYIO.puts("calling imported function")
    end
end

```

```elixir
defmodule MyModule do
	alias Geometry.Rectangle, as: Rectangle
	
	def my_function do
		Rectangle.area(...)
	end
end
```



### 2.3.6 Module attribute

The purpose of module attribute is twofold: they can be used as compile-time constant, and you can register any attribute, which can then be queried in runtime.



```elixir
defmodule Circle do
	@pi 3.14156
	
	def area(r), do: r*r*@pi
	def circumference(r), do: 2*r*@pi
end
```

This is permitted and makes it possible to experiment without storing any files on disk.

The important thing about the @pi constant is that it exists only during the compilation of the module, when the references to it are inlined.



Moreover, attribute can be registered, which means it will be stored in the generated binary and can be accessed at runtime. Elixir registers some module attributes by default.

-> @moduledoc @doc can be used to provide documentation for modules and finctions



```elixir
defmodule Circle do
	@moduledoc "Implements basic circle functions"
	@pi 3.14159
	
	@doc "Computes the area of a circle"
	def area(r), do:r*r*@pi
	
	@doc Computes "the circoumference of a circle"
	def circumference(r), do: 2*r*r*@pi
end

#output
#iex(1)> Code.get_docs(Circle, :moduledoc)
#{1, "Implements basic circle functions"}

#output with help feature
#help feature is h
#iex(2)> h Circle			-> Circle
#Implements basic circle functions
#iex(3)> h Circle.area		-> def area(a)
#Computes the area of a circle

```



### Type specifications

Type specifications (often called *typespecs*) are another important feature based on attributes.

This feature allows you to provide type information for your functions, which can later be analyzed with a static analysis tool called dialyzer

```elixir
defmoducle Circle do
    @pi 3.14159
    @spec area(number) :: number			#Type specification for area/1
    def area(r), do : r*r*@pi
    
    @spec circumference(number) :: number
    def circumference(r), do: 2*r*@pi	#Type specification for circumference/1
end
```

*@spec* attribute to indicate that both functions accept and return a number

remember that Elixir is a dynamic language, so function inputs and output cannot be easily deduced by looking at the function's signature.  Typespecs can help significantly with this, and i can personally attest that it's much easier to understand someone else's code when typespces are provided.

```elixir
#example of typespecs
List.insert_at/3:
@spec insert_at(list, integer, any) :: list
```

> In this book, Writer will not use typespecs but i have to practice by myself for a complex structure which i will implement.
>
> ... Really can i implement? T_T



## 2.4 Understanding the type system

As its core, Elixir uses the Erlang type system. Consequently, integration with Erlang libraries is usually simple. 

### 2.4.1 Numbers

Numbers can be integers or floats, and they work mostly as you'd expect

```elixir
integer : 3
integer written in hex : 0xFF -> 255
float : 3.14
float, exponential notation : 1.0e-2 -> 0.01

div(5,2) = 2
rem(5,2) = 1 -> modular arithmetic

//There is no limit on an integer's size
99999999999999999999999999999999999999999999999999999999
```

***About memory***

- An integer takes up as much space as needed to accommodate the number
- Float occupies either 32 or 64 bits, depending on the build architecture of the virtual machine



### 2.4.2 Atoms

Atoms are literal names constants. ***They're similar to symbols in Ruby or enumeration in C/C++.*** Atom constants start with a colon character, followed by a combination of alphanumerics and/or underscore character.

```elixir
:an_atom
:another_atom
//It is possible to use space in the atom name with the following syntax
:"an atom with space"
```

An atom consists of two parts: ***the text and the value.*** The atom text is whatever you put after the colon character. At runtime, ***this text is kept in the atom table. The value is the data that goes into the variable, and it is merely a reference to the atom table*** 

> -> similar with enum in C/C++

```elixir
variable = :some_atom
```

- Variable doesn't contain the entire text, but only a reference to the atom table.

  ***->  Therefore memory consumption is low, the comparisons are fast and the code is still readable***

#### Aliases

There is another syntax for atom constant. ***You can omit the beginning colon and start with an uppercase character.***

```elixir
AnAtom
#At compile time, it is transformed into this
:"Elixir.AnAtom":
iex(1) > AnAtom == :"Elixir.AnAtom"
true
```

- ***When programmer use am alias, the compiler implicitly adds the Elixir.***
- But if an alias already contains that prefix, It is not added.

```elixir
iex(2) > AnAtom == Elixir.AnAtom
true
```

- Also alias can be used to gibe alternate names to modules

```elixir
iex(3) > alias IO, as: MyIO
iex(4) > MyIO.puts("Hello!")
Hello!
#-> the term alias is used for both things.
iex(5) > MyIO == Elixir.IO
true
```

#### Atoms AS Booleans

***Elixir doesn't have a dedicated Boolean type*** Instead, the atoms :true and :false are used As syntactic sugar.

```elixir
iex(1) > :true == true
true
iex(2) > :false == false
true
```

- ***Always keep in mind that a Boolean is just an atom that has a value of true or false.***

#### Nil and Truthy values

Another special atom is :nil, which works ***somewhat similarly to null from other languages.***

- Can reference nil without a colon

```elixir
iex(1) > nil == : nil
true
```



The atom nil plays a role in Elixir’s additional support for truthfulness. ***The atoms nil and false are treated as falsy values, whereas everything else is treated as a truthy value.***

```elixir
iex(1) > nil || false || 5 || true
5
iex(2)> true && 5
5
iex(3)> false && 5
false
iex(4)> nil && 5
nil
```

Because both nil and false are falsy expressions, the number 5 is returned.

> Similarly with C/C++
>
> ```c++
> int main(){
>     if(a && b){
>         //if a is false then don't check b
>     }
>     
>     if(a || b){
>         //if a is true don't check b
>     }
> }
> ```

Short-circuiting can be used for elegant operation chaining. For example, if you need to fetch a value from cache, a local disk, or a remote database, you can do something like this

```elixir
read_cached || read_from_disk || read_from_database
#A first data that is treated as true is returned 
database_value = connection_established? && read_data
#if connection_established? is not ture then don't need to check read_data
```

In both examples, short-circuit operators make it possible to write concise code without resorting to complicated nested conditional constructs.

